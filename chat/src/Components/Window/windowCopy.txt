import React, { useEffect, useState } from "react";
import { Message } from "../Message/message";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faCircleArrowRight } from "@fortawesome/free-solid-svg-icons";
import { useSelector, useDispatch } from "react-redux";
import "./window.css";
import { HeaderWindow } from "../HeaderWindow/headerWindow";
import { setChatsJson, setGroupJson } from "../../Redux/actions";
import {
  MessageUser,
  filterGroupMessagesByDate,
  getFormattedDate,
} from "../../Objects/objDetails";

export const Window = (props) => {
  const dispatch = useDispatch();

  const reduxUser = useSelector((state) => state.User);

  const chatJSON = useSelector((state) => state.chatJson);
  const groupJson = useSelector((state) => state.GroupJson);
  const group = groupJson[reduxUser.Id];
  // console.log(groupJson, "groupJson");
  // console.log(group, "group");

  const [message, setMessage] = useState("");
  const [selectedMessages, setSelectedMessages] = useState([]);
  const [messages, setMessages] = useState([]);
  const [messageChange, setMessageChange] = useState(false); // Track whether a message was sent
  const [searchContent, setSearchContent] = useState("");
  const isGroupContext = groupJson.hasOwnProperty(reduxUser.Id);

  const reduxMyUser = useSelector((state) => state.MyUser);

  const setInitialChatData = (dataJSON) => {
    if (!isGroupContext) {
      // console.log("ChatsJson");
      // console.log(dataJSON);
      dispatch(setChatsJson(dataJSON));
    }

    if (isGroupContext) {
      console.log("GroupJson");
      console.log(dataJSON[reduxUser.Id]);
      dispatch(setGroupJson(dataJSON));
    }
  };

  const handleChange = (event) => {
    setMessage(event.target.value);
  };

  const handleSendMessage = () => {
    console.log(messages, 1.0);
    console.log(message, 1.01);
    if (message.trim() !== "") {
      // const details = getDetails();

      console.log(group, 1.1);

      const newMessage = MessageUser(message, reduxMyUser);

      console.log(newMessage, 1.2);

      const updatedMessages = messages.map((m) => ({
        ...m,
        IfRead: true,
      }));

      console.log(updatedMessages, 1.3);
      setMessages([...updatedMessages, newMessage]);
      setMessage("");
      setMessageChange(true);
    }
  };

  const handleSelectMessage = (message) => {
    const isSelected = selectedMessages.some(
      (msg) =>
        msg.MessagesId === message.MessagesId &&
        msg.IdOfUser === message.IdOfUser
    );

    if (isSelected) {
      setSelectedMessages((prevSelectedMessages) =>
        prevSelectedMessages.filter(
          (msg) =>
            msg.MessagesId !== message.MessagesId ||
            msg.IdOfUser !== message.IdOfUser
        )
      );
    } else {
      setSelectedMessages((prevSelectedMessages) => [
        ...prevSelectedMessages,
        message,
      ]);
    }
  };

  const handleSetMessages = (chatData) => {
    console.log(chatData, 5.1);
    if (chatData && chatData.messages) {
      const newMessages = chatData.messages.map((message) => ({
        ...message,
      }));

      console.log(newMessages, 5.2);
      setMessages(newMessages);
    } else {
      setMessages([]);
    }
  };

  const updateChatJSON = () => {
    console.log(3);
    // console.log(group.messages, 3.1);
    // console.log(messages, 3.2);

    if (messages !== undefined && messages.length > 0) {
      let updatedChatData;

      if (chatJSON[reduxUser.Id]) {
        // If the user's chatJSON already exists, update it with new messages
        updatedChatData = {
          ...chatJSON,
          [reduxUser.Id]: {
            ...chatJSON[reduxUser.Id],
            messages: [...messages],
          },
        };

        // console.log(updatedChatData);
        setInitialChatData(updatedChatData);
      } else {
        // If the user's chatJSON doesn't exist, use the groupJson instead
        console.log("group Json");
        updatedChatData = {
          ...groupJson,
          [reduxUser.Id]: {
            ...group,
            messages: [...messages],
          },
        };

        console.log(updatedChatData[reduxUser.Id], 3.3);
        setInitialChatData(updatedChatData);
      }
    }
  };

  const handleDeleteMessages = () => {
    selectedMessages.forEach((selectedMsg) => {
      const { MessagesId, IdOfUser } = selectedMsg;
      const updatedMessages = messages.map((m) => {
        const isMessageSelected =
          m.MessagesId === MessagesId && m.IdOfUser === IdOfUser;
        return {
          ...m,
          IfRead: true,
          IfDelete: isMessageSelected ? true : m.IfDelete, // Set IfDelete to true for selected messages
          IfRemoved: isMessageSelected && m.IfDelete ? true : m.IfRemoved, // Set IfRemoved to true for selected messages
          message: isMessageSelected
            ? "âŠ˜ This message has been deleted"
            : m.message, // Change the message to "This message has been deleted"
        };
      });

      console.log(updatedMessages);

      setMessages(updatedMessages);
    });

    setSelectedMessages([]); // Clear the selected messages after updating
    setMessageChange(true);
  };

  const handleMarkAsFavorite = () => {
    selectedMessages.forEach((selectedMsg) => {
      const { MessagesId, IdOfUser } = selectedMsg;
      const updatedMessages = messages.map((m) => {
        const isMessageSelected =
          m.MessagesId === MessagesId && m.IdOfUser === IdOfUser;
        return {
          ...m,
          IfRead: true,
          IfFavorite: isMessageSelected ? true : m.IfFavorite, // Set IfFavorite to true for selected messages
        };
      });
      setMessages(updatedMessages);
    });

    setSelectedMessages([]); // Clear the selected messages after updating
    setMessageChange(true);
  };

  const handleSaveEditMessage = (newMessage) => {
    selectedMessages.forEach((selectedMsg) => {
      const { MessagesId, IdOfUser } = selectedMsg;
      const updatedMessages = messages.map((m) => {
        const isMessageSelected =
          m.MessagesId === MessagesId && m.IdOfUser === IdOfUser;
        return {
          ...m,
          IfRead: true,
          IfEdit: isMessageSelected ? true : m.IfEdit, // Set IfEdit to true for selected messages
          message: isMessageSelected ? newMessage : m.message, // Change the message to newMessage
        };
      });
      setMessages(updatedMessages);
    });

    setSelectedMessages([]); // Clear the selected messages after updating
    setMessageChange(true);
  };

  const findFirstMessagesOfDay = () => {
    const firstMessages = {};
    const dateFirstMessages = {};
    messages.forEach((message) => {
      const formattedDate = getFormattedDate(message.DateTimeOfMsg);
      // const date = message.DateOfMsg;
      if (!dateFirstMessages[formattedDate]) {
        dateFirstMessages[formattedDate] = true;
        firstMessages[message.MessagesId] = true;
      }
    });
    return firstMessages;
  };

  const handleDataFromSelect = (isTrue) => {
    console.log(isTrue);
    setMessages([]); // Clear the selected messages after updating
    setMessageChange(isTrue);
  };

  const firstMessagesOfDay = findFirstMessagesOfDay();

  const firstUnreadMessage = messages.find((m) => !m.IfRead);

  const setSearchText = (Content) => {
    setSearchContent(Content);
  };

  useEffect(() => {
    if (!isGroupContext) {
      setInitialChatData(chatJSON);
      handleSetMessages(chatJSON[reduxUser.Id]);
    }

    if (isGroupContext) {
      console.log("useEffect");
      setInitialChatData(groupJson);
      console.log(group, 4.1);
      const newGroup = filterGroupMessagesByDate(group, reduxMyUser.Id);
      console.log(newGroup, 4.2);
      handleSetMessages(newGroup);
    }
  }, [reduxUser.Id, groupJson]);

  useEffect(() => {
    // console.log(messageChange);
    // console.log("useEffect");
    if (messageChange) {
      // console.log("if useEffect");
      // console.log(2.1);
      // console.log(messages);
      // console.log(messageChange);
      updateChatJSON();
      setMessageChange(false);
    }
    // if (!messageChange) {
    //   console.log("if not useEffect");
    // }
  }, [messages, messageChange]);

  return (
    <div className="window-Container">
      <header className="window-header">
        <HeaderWindow
          userName={reduxUser.Name}
          Img={reduxUser.Img}
          selectedMessages={selectedMessages}
          onDelete={handleDeleteMessages}
          onFavorite={handleMarkAsFavorite}
          onSaveMessage={handleSaveEditMessage}
          onChange={handleDataFromSelect}
          onSearch={setSearchText}
        />
      </header>

      <main className="window-main">
        {messages
          .filter(
            (m) =>
              !m.IfRemoved && (m.IdOfUser === reduxMyUser.Id || !m.IfDelete)
          ) // Filter out removed messages and messages deleted by another user (stranger)
          .map((m, index) => {
            // const isSelected = selectedMessages.includes(index);
            const formattedDate = getFormattedDate(m.DateTimeOfMsg);
            const isFirstMessageOfDay = firstMessagesOfDay[m.MessagesId];
            // console.log(messages);
            return (
              <React.Fragment key={index}>
                {firstUnreadMessage &&
                  m.MessagesId === firstUnreadMessage.MessagesId && (
                    <div className="window-UnreadMessage-separator">
                      <div className="window-unread-line">
                        <p className="window-p-Messages">Unread Messages</p>
                      </div>
                    </div>
                  )}
                {isFirstMessageOfDay && (
                  <div className="window-message-separator">
                    <div className="window-unread-line">
                      <p className="window-p-Messages">{formattedDate}</p>
                    </div>
                  </div>
                )}
                <Message
                  msg={m}
                  searchText={searchContent}
                  onClick={() => handleSelectMessage(m)}
                  selected={selectedMessages.some(
                    (msg) =>
                      msg.MessagesId === m.MessagesId &&
                      msg.IdOfUser === m.IdOfUser
                  )}
                />
              </React.Fragment>
            );
          })}
      </main>

      {reduxUser.Name !== "Window" && (
        <footer className="window-padding">
          <div className="window-send-container">
            <input
              type="text"
              className="window-form-control"
              placeholder="Type the message here"
              value={message}
              onChange={handleChange}
            />
            <FontAwesomeIcon
              icon={faCircleArrowRight}
              className="window-send-icon"
              onClick={handleSendMessage}
            />
          </div>
        </footer>
      )}
    </div>
  );
};

// {reduxUser.Name !== "Window" && (
//   <footer className="window-padding">
//     <div className="window-send-container">
//       <input
//         type="text"
//         className="window-form-control"
//         placeholder="Type the message here"
//         value={message}
//         onChange={handleChange}
//       />
//       <FontAwesomeIcon
//         icon={faCircleArrowRight}
//         className="window-send-icon"
//         onClick={handleSendMessage}
//       />
//     </div>
//   </footer>
// )}

// console.log(
//   groupJson[reduxUser.Id]?.Friends.find(
//     (friend) => friend.PhoneNumber === reduxUser.Id && friend.IfLeft
//   )
// );

// console.log(
//   reduxUser.Name !== "Window" &&
//     groupJson[reduxUser.Id]?.Friends.find(
//       (friend) => friend.PhoneNumber === reduxUser.Id && friend.IfLeft
//     )
// );

// console.log(
//   reduxUser.Name !== "Window" &&
//     groupJson[reduxUser.Id].Friends.find(
//       (friend) => friend.PhoneNumber === reduxUser.Id && friend.IfLeft
//     )
// );

//   console.log(groupJson[reduxUser.Id]?.Friends);

//   if (groupJson[reduxUser.Id]?.Friends)
//   {
// console.log(groupJson[reduxUser.Id]?.Friends);
//   }

// {groupJson[reduxUser.Id]?.Friends &&
//   // Check if the current user is a member and has not left the group
//   !groupJson[reduxUser.Id].Friends.some(
//     (friend) => friend.PhoneNumber === reduxUser.Id && friend.IfLeft
//   ) && (
//     <footer className="window-padding">
//       <div className="window-send-container">
//         <input
//           type="text"
//           className="window-form-control"
//           placeholder="Type the message here"
//           value={message}
//           onChange={handleChange}
//         />
//         <FontAwesomeIcon
//           icon={faCircleArrowRight}
//           className="window-send-icon"
//           onClick={handleSendMessage}
//         />
//       </div>
//     </footer>
//   )}